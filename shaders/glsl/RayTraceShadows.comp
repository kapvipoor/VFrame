#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : require

//#define REPROJECT_SINGLE_CHANNEL

#include "Common.h"
#include "MeshCommon.h"
#include "RayTracingHelper.h"
#include "ReprojectionHelper.h"

int CastPointLightShadow(Light light, vec3 fragPosVS, vec3 fragPosWS)
{
	// The light position is stored in World space
	// The light intensity is in View Space. Hence we 
	// compute the distance between the light and position
	// in view space and ensure it is less than the light's
	// intensity.
	float rayDist 		= 0;
	vec4 LPosWS 		= vec4(light.vector3[0], light.vector3[1], light.vector3[2], 1.0f);
	vec3 LDirVS 		= ((g_Info.data.camView * LPosWS) - vec4(fragPosVS, 1.0)).xyz;
	float distVS 		= length(LDirVS);
	float attenuation 	= max(0.0f, light.intensity - distVS);
	// The ray tracing needs to happen in world space since
	// the BVH is built in world space.
	vec3 LDirWS 		= LPosWS.xyz - fragPosWS;
	rayDist 			= length(LDirWS);
	LDirWS 				= normalize(LDirWS);
	if(attenuation > 0.0)
	{
		if(light.coneAngle > 0.0)
		{
			uint seed 	= genSeed(uint(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_WorkGroupID.x), g_Info.data.frameCount, 16);
			LDirWS.xyz 	= getConeSample(seed, LDirWS.xyz, light.coneAngle);
		}						
		return TraceRay(fragPosWS, LDirWS.xyz, rayDist);	
	}
	return 0;
}

int CastDirectionalShadow(Light light, vec3 fragPosWS)
{
	float rayDist 		= 1e3;
	vec3 LDirWS 		= vec3(light.vector3[0], light.vector3[1], light.vector3[2]);
	if(light.coneAngle > 0.0)
	{
		uint seed 		= genSeed(uint(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_WorkGroupID.x), g_Info.data.frameCount, 16);
		LDirWS 			= getConeSample(seed, LDirWS, light.coneAngle);
	}					
	return TraceRay(fragPosWS.xyz, LDirWS, rayDist);
}

int CastShadow(Light light, vec3 fragPosVS, vec3 fragPosWS)
{
	uint lightType 		= light.type_castShadow >> 16;
	uint castShadow 	= light.type_castShadow - (lightType << 16);
	if(castShadow == 1)
	{
		if(lightType == DIRECTIONAL_LIGHT_TYPE)
		{
			return CastDirectionalShadow(light, fragPosWS);
		}
		else if (lightType == POINT_LIGHT_TYPE)
		{
			return CastPointLightShadow(light, fragPosVS, fragPosWS);
		}
	}
	return 0;	// no shadow
}

float CalculateMoments(bool reprojection_check, ivec2 xy)
{
	float historyLength 	= 1.0f; 
	float accumWeight 		= 1.0f;
	if(reprojection_check)
	{
		// Increment the history length if the reprojection check
		// passes
		historyLength 		= Load(STORE_HISTORY_LENGTH, xy).x + 1.0;

		// Larger the history length, smaller its contribution.
		accumWeight			= 1.0 / historyLength;

		// Accsumulated weight decides how much of history sample will
		// be used for accumulation
		accumWeight 		= max(accumWeight, g_Info.data.shadowMinAccumWeight);
	}

	Store(STORE_HISTORY_LENGTH, xy, vec4(historyLength, 0.0, 0.0, 1.0));
	return accumWeight;
}

float TemporalAccumulateShadow(float curShadow, float preShadow, float accuWeight)
{
	return mix(preShadow, curShadow, accuWeight);
}

// Format is R16G16B16A16. Hence 16 bits per channel to represent per light's
// shadow. At the moment, the only supported light count that contribute to
// shadows is 4. We might later optimize this by reducing the precision and
// resolution per shadow depending on some research and experimentation 
// R16[Dir Light_0 shadow] G16[Point Light_1 shadow] B16[Point Light_2 shadow] A16[Point Light_3 shadow]
layout (local_size_x = THREAD_GROUP_SIZE_X, local_size_y = THREAD_GROUP_SIZE_Y) in;
void main()
{
	vec4 shadowsOut 	= vec4(0);
	int shouldDenoise	= 0;

	ivec2 xy 			= ivec2(gl_GlobalInvocationID.xy);
	vec2 uv 			= XY2RenderUV(xy);
	float sampleDepth 	= SampleNearest(GetDepthTextureID(g_Info.data.pingPongIndex), uv).x;
	if(sampleDepth < 1.0)
	{
		vec4 fragPosVS 	= GetPositionfromDepth(uv, sampleDepth);
		vec4 fragPosWS 	= g_Info.data.invCamView * fragPosVS;

		// Sampling previous frame's shadow values for this position
		// Since we are accumulating the shadows over frame, we do
		// not maintain a previous shadow buffer, instead read and
		// update the Shadow Texture
		bool reprojection_check = ReprojectionFast(uv, xy, SAMPLE_RT_SHADOW_TEMPORAL_ACC, shadowsOut); 
		float accumWeight 		= CalculateMoments(reprojection_check, xy);

		for(uint i = 0; i < g_lights.count; i++)
		{	
			int curShadow = CastShadow(g_lights.lights[i], fragPosVS.xyz, fragPosWS.xyz);
			shadowsOut[i] = TemporalAccumulateShadow(curShadow, shadowsOut[i], accumWeight);
			shouldDenoise += ((shadowsOut[i] < (999*1e-3) && shadowsOut[i] > (1e-6)) ? 1 : 0);
		}

		Store(STORE_RT_SHADOW_TEMPORAL_ACC, xy, shadowsOut);
		Store(STORE_RT_SHADOW_DENOISE, xy, vec4(shouldDenoise, 0, 0, 1.0));
	}
}	